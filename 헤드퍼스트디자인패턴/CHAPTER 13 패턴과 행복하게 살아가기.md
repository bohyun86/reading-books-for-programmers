# CHAPTER 13 패턴과 행복하게 살아가기

## 디자인 패턴의 정의

- 패턴(Pattern): 특정 컨텍스트 내에서 주어진 문제의 해결책
  - 컨텍스트(Context): 패턴이 적용되는 상황, 반복적으로 일어날 수 있는 상황
  - 문제(problem): 컨텍스트 내에서 이뤄야 하는 목표, 컨텍스트 내의 제약조건도 포함
  - 해결책(solution): 제약조건 속에서 누가 적용해도 목표를 이룰 수 있는 일반적인 디자인을 뜻함

- 패턴은 반복적으로 등장하는 문제에 적용할 수 있어야 함

## 용어를 공유하는 5가지 방법

- 다지인 회의에서
  - 불필요한 오해소지를 줄임
- 다른 개발자들과 토론할 때
- 아키텍처 문서에 활용
  - 적은 분량으로 디자인 분명하게 설명 가능
- 코드 주석을 달 때
  - 클래스와 메소드 이름을 만들 때도 패턴을 활용
  - 다른 개발자들이 코드를 이해하는 데 도움
- 개발자 모임에서 사용

## 안티 패턴

- 어떤 문제의 나쁜 해결책에 이르는 길을 알려줌
- 안티 패턴을 알면 좋은 패턴을 더 쉽게 이해할 수 있음


## 객체지향 원칙 정리

- 바뀌는 부분은 캡슐화 한다.
- 상속보다는 구성을 활용한다.
- 구현이 아닌 인터페이스에 맞춰서 프로그래밍한다.
- 상호 작용하는 객체 사이에서는 가능하면 느슨하게 결합한다.
- 클래스는 확장에 대해서는 열려 있지만 변경에 대해서는 닫혀 있어야 한다.
- 추상화된 것에 의존하게 만들고 구체적인 것에 의존하지 않게 만든다.
- 진짜 절친한 친구에게만 말해라.
- 먼저 연락하지 마세요. 저희가 연락 드리겠습니다.
- 어떤 클래스가 변화되어야 하는 이유는 오직 하나여야 한다.

## 객체지향 기초

- 추상화
- 캡슐화
- 상속
- 다형성

## 패턴 설명 요약

- 데코레이터 패턴: 객체를 감싸서 새로운 행동을 제공
- 상태 패턴: 상태를 기반으로 하는 행동을 캡슐화한 다음 위임으로 필요한 행동을 선택
- 반복자 패턴: 컬렉션이 어떤 식으로 구현되었는지 드러내지 않으면서도 컬렉션 내에 있는 모든 객체를 대상으로 반복 작업을 처리
- 퍼사드 패턴: 일련의 클래스에 간단한 인터페이스를 제공
- 전략 패턴: 교환 가능한 행동을 캡슐화하고 위임으로 어떤 행동을 사용할지 결정
- 프록시 패턴: 객체를 감싸서 그 객체로의 접근을 제어
- 팩토리 메소드 패턴 : 서브클래스에서 생성할 구상 클래스를 결정
- 어댑터 패턴: 객체를 감싸서 다른 인터페이스를 제공
- 옵저버 패턴: 상태가 변경되면 다른 객체들에게 연락을 돌릴 수 있게 함
- 템플릿 메소드 패턴: 알고리즘의 개별 단계를 구현하는 방법을 서브클래스에서 결정함
- 컴포지트 패턴: 클라이언트에서 객체 컬렉션과 개별 객체를 똑같이 다룰 수 있도록 함
- 싱글턴 패턴: 딱 한 객체만 생성되도록 함
- 추상 팩토리 패턴: 클라이언트에서 구상 클래스를 지정하지 않으면서도 객체군을 생성할 수 있도록 해줌
- 커맨드 패턴: 요청을 객체로 감쌈
